"use client";

import EducationalInfo from '@/components/EducationalInfo';
import ExamResult from '@/components/ExamResult';
import React, { useState } from 'react';
import { Card } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';

export default function CflProperties() {
  // State for CFL pumping lemma demo
  const [stringLength, setStringLength] = useState<number>(10);
  const [pumpingLength, setPumpingLength] = useState<number>(3);
  const [originalString, setOriginalString] = useState<string>("aaabbbccc");
  const [decomposition, setDecomposition] = useState<{u: string, v: string, x: string, y: string, z: string}>({
    u: "a", v: "aa", x: "bbb", y: "cc", z: "c"
  });
  const [pumpingCount, setPumpingCount] = useState<number>(2);
  const [pumpedString, setPumpedString] = useState<string>("");
  
  // State for CFL closure properties demo
  const [cfl1, setCfl1] = useState<string>("{a^n b^n | n >= 0}");
  const [cfl2, setCfl2] = useState<string>("{b^m c^m | m >= 0}");
  const [operationResult, setOperationResult] = useState<string>("");
  const [selectedOperation, setSelectedOperation] = useState<string>("union");

  // Apply CFL pumping lemma
  const applyPumpingLemma = () => {
    const { u, v, x, y, z } = decomposition;
    
    // Validate decomposition
    if (originalString !== u + v + x + y + z) {
      setPumpedString("Error: Decomposition doesn't match the original string");
      return;
    }
    
    // Check |vy| > 0
    if (v.length + y.length === 0) {
      setPumpedString("Error: |vy| must be greater than 0");
      return;
    }
    
    // Check |vxy| <= p (pumping length)
    if (v.length + x.length + y.length > pumpingLength) {
      setPumpedString("Error: |vxy| must be at most " + pumpingLength);
      return;
    }
    
    // Pump the string with i iterations
    const pumpedV = v.repeat(pumpingCount);
    const pumpedY = y.repeat(pumpingCount);
    const result = u + pumpedV + x + pumpedY + z;
    
    setPumpedString(result);
  };

  // Apply closure operation
  const applyClosureOperation = () => {
    let result = "";
    
    switch (selectedOperation) {
      case "union":
        result = `${cfl1} ∪ ${cfl2}`;
        break;
      case "concatenation":
        result = `${cfl1} · ${cfl2}`;
        break;
      case "kleeneStar":
        result = `(${cfl1})*`;
        break;
      case "intersection":
        result = `${cfl1} ∩ ${cfl2} (Note: CFLs are not closed under intersection in general)`;
        break;
      case "complement":
        result = `${cfl1}^C (Note: CFLs are not closed under complement in general)`;
        break;
      case "reversal":
        result = `${cfl1}^R`;
        break;
      case "substitution":
        result = `Result of substituting each symbol in ${cfl1} with strings from other CFLs`;
        break;
      case "homomorphism":
        result = `h(${cfl1}) where h is a homomorphism`;
        break;
      default:
        result = "Please select an operation";
    }
    
    setOperationResult(result);
  };

  return (
    <div className="container mx-auto py-6">
      <h1 className="text-3xl font-bold text-gray-900 dark:text-white mb-6">
        Context-Free Languages Properties
      </h1>

      <EducationalInfo 
        topic="Properties of Context-Free Languages"
        description="Understanding the fundamental properties of context-free languages, including pumping lemma, closure properties, and decision problems."
        theory={{
          definition: "Context-free languages are those generated by context-free grammars (CFGs) or recognized by pushdown automata (PDAs). They form an important class of formal languages in the Chomsky hierarchy.",
          keyPoints: [
            "CFLs can express nested structures and are more powerful than regular languages",
            "Every regular language is also a context-free language",
            "CFLs are recognized by pushdown automata (PDAs)",
            "CFLs can be generated by context-free grammars (CFGs)",
            "The pumping lemma for CFLs helps prove that certain languages are not context-free"
          ],
          applications: [
            "Parsing programming languages and their syntax",
            "Natural language processing for nested structures",
            "Expression validation and evaluation",
            "Compiler design and implementation",
            "Formal verification of systems"
          ]
        }}
        mumbaiUniversity={{
          syllabus: [
            "Context-Free Languages and their properties",
            "Pumping lemma for context-free languages",
            "Closure properties of CFLs",
            "Decision problems for CFLs"
          ],
          marks: "10-15",
          commonQuestions: [
            "Prove that language L is not context-free using pumping lemma",
            "Explain the closure properties of context-free languages",
            "Discuss the decision problems for context-free languages",
            "Convert a CFG to Chomsky Normal Form",
            "Explain the relationship between PDAs and CFLs"
          ],
          examTips: [
            "Learn the pumping lemma thoroughly and practice its application",
            "Memorize which operations preserve context-freeness",
            "Study the algorithms for decidable problems",
            "Practice converting between different grammar forms",
            "Pay attention to the special case of intersection with regular languages"
          ]
        }}
        algorithm={{
          steps: [
            "Identify if a language might be context-free by checking if it has nested dependencies",
            "If trying to prove a language is not context-free, choose an appropriate string that satisfies the pumping lemma constraints",
            "Decompose the string according to the pumping lemma conditions",
            "Find a value of i (often i=0 or i=2) such that pumping leads to a string not in the language",
            "For closure properties, construct new grammars that represent the result of the operation"
          ],
          complexity: {
            time: "Varies",
            space: "Varies"
          }
        }}
      />

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
        <Card className="p-6">
          <h2 className="text-xl font-semibold mb-4 text-gray-800 dark:text-gray-200">
            CFL Pumping Lemma Visualizer
          </h2>
          
          <div className="mb-4">
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Original String
            </label>
            <Input 
              value={originalString} 
              onChange={(e) => setOriginalString(e.target.value)} 
              placeholder="e.g., aaabbbccc"
              className="text-gray-900 dark:text-white"
            />
          </div>
          
          <div className="mb-4">
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Pumping Length (p)
            </label>
            <Input 
              type="number"
              value={pumpingLength} 
              onChange={(e) => setPumpingLength(parseInt(e.target.value) || 1)} 
              min="1"
              className="text-gray-900 dark:text-white"
            />
          </div>
          
          <div className="grid grid-cols-5 gap-2 mb-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                u
              </label>
              <Input 
                value={decomposition.u} 
                onChange={(e) => setDecomposition({...decomposition, u: e.target.value})} 
                className="text-gray-900 dark:text-white"
              />
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                v
              </label>
              <Input 
                value={decomposition.v} 
                onChange={(e) => setDecomposition({...decomposition, v: e.target.value})} 
                className="text-gray-900 dark:text-white"
              />
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                x
              </label>
              <Input 
                value={decomposition.x} 
                onChange={(e) => setDecomposition({...decomposition, x: e.target.value})} 
                className="text-gray-900 dark:text-white"
              />
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                y
              </label>
              <Input 
                value={decomposition.y} 
                onChange={(e) => setDecomposition({...decomposition, y: e.target.value})} 
                className="text-gray-900 dark:text-white"
              />
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                z
              </label>
              <Input 
                value={decomposition.z} 
                onChange={(e) => setDecomposition({...decomposition, z: e.target.value})} 
                className="text-gray-900 dark:text-white"
              />
            </div>
          </div>
          
          <div className="mb-4">
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Pumping Count (i)
            </label>
            <Input 
              type="number"
              value={pumpingCount} 
              onChange={(e) => setPumpingCount(parseInt(e.target.value) || 0)} 
              min="0"
              className="text-gray-900 dark:text-white"
            />
          </div>
          
          <Button 
            onClick={applyPumpingLemma} 
            className="w-full mb-4"
          >
            Apply Pumping Lemma
          </Button>
          
          {pumpedString && (
            <div className="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
              <h3 className="font-medium mb-2 text-gray-900 dark:text-white">Result:</h3>
              <p className="break-all text-gray-900 dark:text-white">
                {pumpedString}
              </p>
            </div>
          )}
        </Card>
        
        <Card className="p-6">
          <h2 className="text-xl font-semibold mb-4 text-gray-800 dark:text-gray-200">
            CFL Closure Properties
          </h2>
          
          <div className="mb-4">
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Context-Free Language 1
            </label>
            <Input 
              value={cfl1} 
              onChange={(e) => setCfl1(e.target.value)} 
              placeholder="e.g., {a^n b^n | n >= 0}"
              className="text-gray-900 dark:text-white"
            />
          </div>
          
          <div className="mb-4">
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Context-Free Language 2
            </label>
            <Input 
              value={cfl2} 
              onChange={(e) => setCfl2(e.target.value)} 
              placeholder="e.g., {b^m c^m | m >= 0}"
              className="text-gray-900 dark:text-white"
            />
          </div>
          
          <div className="mb-4">
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Operation
            </label>
            <select 
              value={selectedOperation} 
              onChange={(e) => setSelectedOperation(e.target.value)}
              className="w-full p-2 border rounded-md bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
            >
              <option value="union">Union (Closed)</option>
              <option value="concatenation">Concatenation (Closed)</option>
              <option value="kleeneStar">Kleene Star (Closed)</option>
              <option value="intersection">Intersection (Not Closed)</option>
              <option value="complement">Complement (Not Closed)</option>
              <option value="reversal">Reversal (Closed)</option>
              <option value="substitution">Substitution (Closed)</option>
              <option value="homomorphism">Homomorphism (Closed)</option>
            </select>
          </div>
          
          <Button 
            onClick={applyClosureOperation} 
            className="w-full mb-4"
          >
            Apply Operation
          </Button>
          
          {operationResult && (
            <div className="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
              <h3 className="font-medium mb-2 text-gray-900 dark:text-white">Result:</h3>
              <p className="text-gray-900 dark:text-white">
                {operationResult}
              </p>
              {selectedOperation === "intersection" || selectedOperation === "complement" ? (
                <p className="text-amber-600 dark:text-amber-400 mt-2">
                  Note: This is an operation under which CFLs are not closed in general.
                </p>
              ) : null}
            </div>
          )}
        </Card>
      </div>

      <Card className="p-6 mb-8">
        <h2 className="text-xl font-semibold mb-4 text-gray-800 dark:text-gray-200">
          Proving Languages are Not Context-Free
        </h2>
        
        <div className="text-gray-900 dark:text-white">
          <h3 className="font-medium mb-2">Steps to use the CFL Pumping Lemma to prove a language is not context-free:</h3>
          <ol className="list-decimal list-inside space-y-2">
            <li>Assume the language L is context-free.</li>
            <li>By the pumping lemma, there exists a pumping length p.</li>
            <li>Choose a string s in L such that |s| &gt;= p. This is your "witness string".</li>
            <li>Consider any decomposition s = uvxyz where:
              <ul className="list-disc list-inside ml-6 mt-1">
                <li>|vxy| &lt;= p</li>
                <li>|vy| &gt; 0</li>
              </ul>
            </li>
            <li>Find a value of i (often i=0 or i=2) such that uv^i xy^i z is not in L.</li>
            <li>This contradiction proves L is not context-free.</li>
          </ol>
          
          <h3 className="font-medium mt-6 mb-2">Example: Proving L = a^n b^n c^n where n &gt;= 1 is not context-free</h3>
          <ol className="list-decimal list-inside space-y-2">
            <li>Assume L is context-free with pumping length p.</li>
            <li>Choose s = a^p b^p c^p, clearly |s| &gt;= p and s is in L.</li>
            <li>For any decomposition s = uvxyz where |vxy| &lt;= p and |vy| &gt; 0:
              <ul className="list-disc list-inside ml-6 mt-1">
                <li>Since |vxy| &lt;= p, vxy must be contained within a^p or span two regions.</li>
                <li>If vxy is within a^p, then v and y contain only a's.</li>
                <li>If vxy spans two regions, then v and y contain different symbols.</li>
              </ul>
            </li>
            <li>When we pump with i=2: uv^2 xy^2 z will have unequal numbers of a's, b's, and c's.</li>
            <li>Thus, uv^2 xy^2 z is not in L, contradicting the pumping lemma.</li>
            <li>Therefore, L is not context-free.</li>
          </ol>
        </div>
      </Card>
      
      <Card className="p-6 mb-8">
        <h2 className="text-xl font-semibold mb-4 text-gray-800 dark:text-gray-200">
          Summary: CFL Decision Problems
        </h2>
        
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-gray-900 dark:text-white">
          <div>
            <h3 className="font-medium mb-2">Decidable Problems for CFLs:</h3>
            <ul className="list-disc list-inside space-y-1">
              <li>Membership: Is w ∈ L?</li>
              <li>Emptiness: Is L = ∅?</li>
              <li>Finiteness: Is L finite?</li>
              <li>Membership in L ∩ R (R is regular)</li>
            </ul>
          </div>
          
          <div>
            <h3 className="font-medium mb-2">Undecidable Problems for CFLs:</h3>
            <ul className="list-disc list-inside space-y-1">
              <li>Universality: Is L = Σ*?</li>
              <li>Equivalence: Is L₁ = L₂?</li>
              <li>Inclusion: Is L₁ ⊆ L₂?</li>
              <li>Disjointness: Is L₁ ∩ L₂ = ∅?</li>
              <li>Ambiguity: Is G an ambiguous CFG?</li>
            </ul>
          </div>
        </div>
      </Card>

      <ExamResult
        title="Context-Free Languages Properties in Exams"
        input="Context-Free Languages Properties"
        result={true}
        steps={[
          {
            stepNumber: 1,
            description: "Understanding the Pumping Lemma for CFLs",
            explanation: "Learn the formal definition and conditions of the pumping lemma for CFLs"
          },
          {
            stepNumber: 2,
            description: "Applying Pumping Lemma to prove a language is not context-free",
            explanation: "Select appropriate witness string and show that it violates the pumping lemma"
          },
          {
            stepNumber: 3,
            description: "Analyzing Closure Properties",
            explanation: "Determine whether operations preserve context-freeness and how to construct new grammars"
          },
          {
            stepNumber: 4,
            description: "Identifying Decidable Problems",
            explanation: "Know which problems are decidable for CFLs and which algorithms to use"
          }
        ]}
        finalAnswer="Understanding CFL properties is crucial for formal language theory questions in exams"
        examFormat={{
          question: "Prove that the language L = {a^n b^n c^n | n ≥ 1} is not context-free using the pumping lemma.",
          solution: [
            "Assume L is context-free with pumping length p.",
            "Choose s = a^p b^p c^p as our witness string, which is in L and has |s| ≥ p.",
            "By the pumping lemma, s can be written as s = uvxyz where |vxy| ≤ p and |vy| > 0.",
            "Since |vxy| ≤ p, vxy must be contained within the first p characters or span two regions.",
            "If vxy contains only a's, then v and y contain only a's.",
            "If vxy contains a's and b's, then pumping would create a string with improper ordering.",
            "If vxy contains only b's, then v and y contain only b's.",
            "For any of these cases, the string uv^2xy^2z will not have equal numbers of a's, b's and c's.",
            "Therefore, uv^2xy^2z is not in L, contradicting the pumping lemma.",
            "Hence, L is not context-free."
          ],
          conclusion: "The language L = {a^n b^n c^n | n ≥ 1} is not context-free.",
          marks: 10
        }}
      />
    </div>
  );
}
